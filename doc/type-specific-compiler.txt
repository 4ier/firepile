// Here's a sketch of how a type-specific compiler might look.  The strings for
// matching methods should probably be matching the signatures generated by
// TypeFlow.

trait TypeCompiler[A] extends Marshal[A] {
  implicit def opt(t: Tree): Option[Tree] = Some(t)

  def rawType: String
  def compileType: Option[Tree] = None
  def compileStruct: Option[Tree] = None
  def compileMethod(sig: String): Option[Tree] = None
  def compileCall(target: Tree, sig: String, args: List[Tree]): Option[Tree] = None
  def compileStaticCall(sig: String, args: List[Tree]): Option[Tree] = None
  def compileField(target: Tree, sig: String): Option[Tree] = None
  def compileStaticField(sig: String): Option[Tree] = None
  def compileNew(sig: String, args: List[Tree]): Option[Tree] = None
}

class RailCompiler[A: TypeCompiler] extends TypeCompiler[Array[A]] {
  lazy val aCompiler = implicitly[TypeCompiler[A]]
  lazy val arrayCompiler = implicitly[TypeCompiler[Array[A]]]

  override def rawType = "[" + aCompiler.rawType
  override def compileType = arrayCompiler.compileType
  override def compileStruct = arrayCompiler.compileStruct
  def get(target: Tree, index: Tree) = ArrayAccess(Select(target, "data"), index)
  def set(target: Tree, index: Tree, value: Tree) = Assign(ArrayAccess(Select(target, "data"), index), value)
  def length(target: Tree) = Select(target, "length")
}

class ArrayCompiler[A: TypeCompiler] extends TypeCompiler[Array[A]] {
  lazy val aCompiler = implicitly[TypeCompiler[A]]
  lazy val name = freshName("__array")

  override def rawType = "Lscala/Array;"
  override def compileType = StructType(name)
  override def compileStruct =
    StructDef(name,
              VarDef(ValueType("int"), "length")
              VarDef(MemType("global", PtrType(aCompiler.compileType)), data))

  override def compileCall(target: Tree, sig: String, args: List[Tree]) = sig match {
    case "fromFunction(Lscala.Function1;ILscala.reflect.ClassManifest;)Ljava/lang/Object;" => Call(Id("Array_fromFunction")
    case "apply(I)Ljava/lang/Object;" => ArrayAccess(Select(target, "data"), args(0))
    case "update(ILjava/lang/Object;)V" => Assign(ArrayAccess(Select(target, "data"), args(0)), args(1))
    case "length()I" => Select(target, "length")
    case _ => null
  }
}

class StringCompiler extends TypeCompiler[String] {
  override def rawType = "Ljava/lang/String;"
  override def compileType = MemType("global", PtrType(ValueType("char")))
  override def compileMethod(sig: String) = {
    sig match {
      case "equals(Ljava/lang/Object;)Z" => null
      case _ => null
    }
  }
  override def compileCall(target: Tree, sig: String, args: List[Tree]) = {
    (target,sig,args) match {
      case (o1, "equals(Ljava/lang/Object;)Z", List(o2)) => Bin(o1, "==", o2)
      case _ => null
    }
  }
  override def compileCall(target: Tree, sig: String, args: List[Tree]) = {
    (target,sig,args) match {
      case (o1, "equals(Ljava/lang/Object;)Z", List(o2)) => Bin(o1, "==", o2)
      case _ => null
    }
  }
}
